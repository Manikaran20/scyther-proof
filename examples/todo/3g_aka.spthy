theory 3G_AKA begin

protocol AKA
{

  // Hack to represent setup of sequence number and key shared between HE and U
  0. HE -> U : {'0', SEQ, K}k(HE,U)

  // The encryption is used to model the secure channel.
  1. HE ->   : {'1', r, h('f2',K,r), h('f3',K,r), h('f4',K,r), {SEQ}h('f5',K,r), h('f1',SEQ,r)}k(HE,SN)
        -> SN: {'1', r, RES,         CK,          IK,          AUTN1,            AUTN2        }k(HE,SN)

  2. SN ->   : r, AUTN1,            AUTN2
        -> U : r, {SEQ}h('f5',K,r), h('f1',SEQ,r)

  3. U  ->   : h('f2',K,r)
        -> SN: RES
}


properties (of AKA)
  auto: msc-typing

  HE_K_secret:   secret(HE, -, K, {HE, U})
  HE_CK_secret:  secret(HE, -, h('f3',K,r), {HE,U,SN})
  HE_IK_secret:  secret(HE, -, h('f4',K,r), {HE,U,SN})
  HE_AK_secret:  secret(HE, -, h('f5',K,r), {HE,U})
  HE_SEQ_secret: secret(HE, -, SEQ, {HE,U})

axiom (of AKA) uncompromised_HE_talks_to_uncompromised_U:
  premises
    "role(3) = HE"
    "uncompromised(HE#3)"
  imply 
    "uncompromised(U#3)"

axiom (of AKA) uncompromised_HE_talks_to_uncompromised_SN:
  premises
    "role(3) = HE"
    "uncompromised(HE#3)"
  imply 
    "uncompromised(SN#3)"

properties (of AKA)
  U_K_secret:    secret(U,  0, K,   {HE,U})
  U_SEQ_secret:  secret(U,  0, SEQ, {HE,U})

  SN_CK_secret:  secret(SN, 1, CK,  {HE,SN})
  SN_IK_secret:  secret(SN, 1, IK,  {HE,SN})

  U_CK_secret:  secret(U, 0, h('f3',K,r),  {HE,U})
  U_IK_secret:  secret(U, 0, h('f4',K,r),  {HE,U})
  U_AK_secret:  secret(U, 0, h('f5',K,r),  {HE,U})

property (of AKA) U_auth:
  premises
    "role(1) = U"
    "step(1, U_2)"
    "uncompromised(HE#1, U#1)"
  imply threads 2, 3 such that
    " role(2) = SN
    & r#2     = r#1
    & RES#2   = h('f2',K#1,r#1)
    & CK#2    = h('f3',K#1,r#1)
    & IK#2    = h('f4',K#1,r#1)
    & AUTN1#2 = {SEQ#1}h('f5',K#1,r#1)
    & AUTN2#2 = h('f1',SEQ#1,r#1)

    & role(3) = HE
    & U#3     = U#1
    & HE#3    = HE#1
    & SEQ#3   = SEQ#1
    & K#3     = K#1
    & r#3     = r#1

    & St(3, HE_0) < St(1, U_0)
                  < St(1, U_2)
    & St(3, HE_1) < St(2, SN_1) <
      St(2, SN_2) < St(1, U_2)
    & St(3, HE_0) < St(3, HE_1)
    "
    
property (of AKA) SN_auth:
  premises
    "role(2) = SN"
    "step(2, SN_3)"
    "uncompromised(HE#2, SN#2)"
  imply threads 1, 3 such that
    " role(1) = U
    & r#2     = r#1
    & RES#2   = h('f2',K#1,r#1)
    & CK#2    = h('f3',K#1,r#1)
    & IK#2    = h('f4',K#1,r#1)
    & AUTN1#2 = {SEQ#1}h('f5',K#1,r#1)
    & AUTN2#2 = h('f1',SEQ#1,r#1)

    & role(3) = HE
    & SN#3    = SN#2
    & HE#3    = HE#2
    & RES#2   = h('f2',K#3,r#3)
    & CK#2    = h('f3',K#3,r#3)
    & IK#2    = h('f4',K#3,r#3)
    & AUTN1#2 = {SEQ#3}h('f5',K#3,r#3)
    & AUTN2#2 = h('f1',SEQ#3,r#3)

    & St(3, HE_0) < St(1, U_0)
                  < St(1, U_2)
    & St(3, HE_1) < St(2, SN_1)

      // does not hold as the received message could be generated by another
      // serving network
      // St(2, SN_2) < St(1, U_2)

    &               St(1, U_2) <
      St(1, U_3)  < St(2, SN_3)
    & St(2, SN_1) < St(2, SN_2) < St(2, SN_3)
    & St(3, HE_0) < St(3, HE_1) < St(1, U_2)
    "

end
