theory nsl
begin

// Isabelle checking: 24 sec

protocol nsl3
{
  1. I -> R: {'1',ni,I}pk(R)
  2. I <- R: {'2',ni,nr,R}pk(I)
  3. I -> R: {'3',nr}pk(R)
  // 4. I <- R: {'4',Payload1}ni
  // 5. I -> R: {'5',Payload2}ni
}

properties (of nsl3) 
  auto: msc-typing

/*
  ltk_secrecy: ltk-secrecy

  I_ni_secrecy:   secret(I, -, ni,    {I,R}) 
  R_nr_secrecy:   secret(R, -, nr,    {I,R}) 
  I_nr_secrecy:   secret(I, 2, nr,    {I,R}) 
  R_ni_secrecy:   secret(R, 3, ni,    {I,R}) 

  weak_atomicity: weakly-atomic 

property (of nsl3) I_ni_synch:
  premises
    "role(1) = I"
    "step(1, I_3)"
    "uncompromised(I#1,R#1)"
  imply a thread 2 such that
    "  role(2) = R
     & I#1  = I#2
     & R#1  = R#2
     & ni#1 = ni#2
     & nr#1 = nr#2
     &   St(1,I_1) < St(2,R_1) 
       < St(2,R_2) < St(1,I_2) 
       < St(1,I_3)"

property (of nsl3) R_ni_synch:
  premises
    "role(1) = R"
    "step(1, R_3)"
    "uncompromised(I#1,R#1)"
  imply a thread 2 such that
    "  role(2) = I
     & I#1  = I#2
     & R#1  = R#2
     & ni#1 = ni#2
     & nr#1 = nr#2
     &   St(2,I_1) < St(1,R_1) 
       < St(1,R_2) < St(2,I_2) 
       < St(2,I_3) < St(1,R_3)"

/*
property (of nsl3) I_2_nr_eq:
  premises
    "role(1) = I"
    "role(2) = R"
    "nr#1 = nr#2"
    "step(1, I_2)"
    "uncompromised(I#1,R#1)"
  imply 
    "   inst(1, I_1_pt) = inst(2, R_1_pt)
     &  inst(1, I_2_pt) = inst(2, R_2_pt)

     &   St(1, I_1) < inst(1, I_1_pt) < St(2, R_1)
       < St(2, R_2) < inst(1, I_2_pt) < St(1, I_2)
    "

property (of nsl3) R_1_ni_eq:
  premises
    "role(1) = I"
    "role(2) = R"
    "ni#1 = ni#2"
    "step(2, R_3)"
    "uncompromised(I#1,R#1)"
  imply 
    "   inst(1, I_1_pt) = inst(2, R_1_pt)
     &  inst(1, I_2_pt) = inst(2, R_2_pt)
     &  inst(1, I_3_pt) = inst(2, R_3_pt)

     &    St(1, I_1) < inst(1, I_1_pt) < St(2, R_1)
        < St(2, R_2) < inst(1, I_2_pt) < St(1, I_2)
        < St(1, I_3) < inst(1, I_3_pt) < St(2, R_3)
    "

properties (of nsl3)
  R_inv_ni_sec:   secret(R, 3, inv(ni),  {I,R})
  R_Payload1_sec: secret(R, -, Payload1, {I,R})
  I_Payload1_sec: secret(I, 4, Payload1, {I,R})

  I_Payload2_sec: secret(I, -, Payload2, {I,R})
  R_Payload2_sec: secret(R, 5, Payload2, {I,R})
*/
*/

end

