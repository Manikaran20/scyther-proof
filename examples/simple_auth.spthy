theory simple_auth
begin

protocol P {
  1. I -> R: ni
  2. I <- R: {'2', ni, nr}k(I,R)
  3. I -> R: {'3', msg1}nr
}


property (of P) ni_first_send:
  premises
    "role(0) = I"
    "knows(ni#0)"
  imply
    "St(0, I_1) < Ln(ni#0)"

properties (of P)
  I_sec_k_I_R: secret(I, -, k(I,R), {I,R})
  R_sec_k_I_R: secret(R, -, k(I,R), {I,R})

  R_sec_nr: secret(R, -, nr, {I,R})
  // I_sec_ni: secret(I, 2, nr, {I,R})

/*

property (of P) I_ni_eq:
  premises
    "role(1) = I"
    "role(2) = R"
    "step(1, I_2)"
    "nr#1 = nr#2"
    "uncompromised( I#2, R#2 )"
  imply
    " inst(1, I_1_pt) = inst(2, R_1_pt)
    & inst(1, I_2_pt) = inst(2, R_2_pt)
    & St(1, I_1) < inst(1, I_1_pt) < St(2, R_1) <
      St(2, R_2) < inst(1, I_2_pt) < St(1, I_2)
    "
*/

property (of P) I_nisynch:
  premises
    "role(1) = I"
    "step(1, I_2)"
    "uncompromised( I#1, R#1 )"
  imply a thread 2 such that
    " role(2) = R
    & inst(1, I_1_pt) = inst(2, R_1_pt)
    & inst(1, I_2_pt) = inst(2, R_2_pt)
    & St(1, I_1) < St(2, R_1) <
      St(2, R_2) < St(1, I_2)
    "

// properties (of P)
  // I_sec_inv_nr: secret(I, 2, inv(nr), {I,R})
  // I_sec_msg1:   secret(I, -, msg1, {I,R})
  // R_sec_msg1:   secret(R, 3, msg1, {I,R})

end
