theory CR_Paper
begin

section{* CR Protocol: The Running Example of Our Paper *}

protocol CR 
{
  1. C -> S: {n}pk(S)
  2. C <- S: h(n)
}



subsection{* Security Properties *}

properties (of CR) 
  auto: auto-properties
  C_n_secrecy: secret(C, 1, n,     {C,S}  )

property (of CR) C_ni_synch:
  premises
    "role(1) = C"
    "step(1, C_2)"
    "uncompromised(C#1, S#1)"
  imply a thread 2 such that
    "  role(2) = S
     & S#1  = S#2
     & n#1 = n#2
     &   St(1,C_1) < St(2,S_1) 
       < St(2,S_2) < St(1,C_2)"


section{* A Strengthened Variant *}

text{*
  The purpose of this strengthened variant is to show that the proofs are
  somehow continuous with respect to changes to the protocol. Here, we add the
  client identity to the first and second message in order to prove agreement
  on both client and server identity. The proofs are the same as for the CR
  protocol.

  Note that our the Isabelle output currently does not do name mangling and
  hence we have to name the roles in the CR2 protocol differently from the ones
  in the CR protocol.
*}

protocol CR2
{
  1. C2 -> S2: {C2, n}pk(S2)
  2. C2 <- S2: h(C2, n)
}

properties (of CR2) 
  auto: auto-properties
  C2_n_secrecy:    secret(C2, 1, n, {C2,S2}  )

property (of CR2) C2_ni_synch:
  premises
    "role(1) = C2"
    "step(1, C2_2)"
    "uncompromised(C2#1, S2#1)"
  imply a thread 2 such that
    "  role(2) = S2
     & S2#1  = S2#2
     & C2#1  = C2#2
     & n#1 = n#2
     &   St(1,C2_1) < St(2,S2_1) 
       < St(2,S2_2) < St(1,C2_2)"

end
