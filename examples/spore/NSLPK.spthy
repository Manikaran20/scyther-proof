theory NSLPK
begin

section{* The Needham-Schroeder-Lowe Public-Key Protocol *}

text{*
  Modelled after SPORE.

  Note that we do identify the otherwise implicit typing explicitely using
  global constants.
*}


protocol nslpk
{
  // We model a single CA server role, which is used to answer both the
  // requests from A and B.
  ca1. -> S: A, B 
  ca2. <- S: sign{'ca2', pk(B), B}pk(S) 

  ca1. I -> : I, R
  ca2. I <- : sign{'ca2', pkR,    R}pk(S)

  1. I ->  : {'1', ni, I}pkR    // TODO: Update type invariant inference such
       -> R: {'1', ni, I}pk(R)  // that we can receive agent name into msg. variable

  ca1. R -> : R, I
  ca2. R <- : sign{'ca2', pkI,  I}pk(S)
     
  2.   <- R: {'2', ni, nr, R}pkI
     I <-  : {'2', ni, nr, R}pk(I)

  3. I ->  : {'3', nr}pkR
       -> R: {'3', nr}pk(R)
}


subsection{* Assumptions *}

text{* 
  Initiators as well as responders talk to an uncompromised server. 
*}

axiom (of nslpk) I_uncompromised_S:
  premises
    "role(1) = I"
  imply "uncompromised(S#1)"

axiom (of nslpk) R_uncompromised_S:
  premises
    "role(1) = R"
  imply "uncompromised(S#1)"


subsection{* Security Properties *}

properties (of nslpk) 
  auto: msc-typing

property (of nslpk) I_pkR_auth:
  premises
    "role(1) = I"
    "step(1, I_ca2)"
  imply
    "pkR#1 = pk(R#1)"

property (of nslpk) R_pkI_auth:
  premises
    "role(1) = R"
    "step(1, R_ca2)"
  imply
    "pkI#1 = pk(I#1)"

properties (of nslpk)
  I_ni_secrecy: secret(I, -, ni, {I,R})
  R_nr_secrecy: secret(R, -, nr, {I,R})
  I_nr_secrecy: secret(I, 2, nr, {I,R})
  R_ni_secrecy: secret(R, 3, ni, {I,R})

property (of nslpk) I_ni_synch:
  premises
    "role(1) = I"
    "step(1, I_2)"
    "uncompromised(I#1, R#1)"
  imply a thread 2 such that
    "  role(2) = R
     & I#1  = I#2
     & R#1  = R#2
     & ni#1 = ni#2
     & nr#1 = nr#2 
     
     & St(1, I_1) < St(2, R_1)
     & St(2, R_2) < St(1, I_2)
     & St(1, I_1) < St(1, I_2)
     & St(2, R_1) < St(2, R_2)
    "

property (of nslpk) R_ni_synch:
  premises
    "role(2) = R"
    "step(2, R_3)"
    "uncompromised(I#2, R#2)"
  imply a thread 1 such that
    "  role(1) = I
     & I#1  = I#2
     & R#1  = R#2
     & ni#1 = ni#2
     & nr#1 = nr#2

     & St(1, I_1) < St(2, R_1)
     & St(2, R_2) < St(1, I_2)
     & St(1, I_3) < St(2, R_3)
     & St(1, I_1) < St(1, I_2) < St(1, I_3)
     & St(2, R_1) < St(2, R_2) < St(2, R_3)
    "

end

